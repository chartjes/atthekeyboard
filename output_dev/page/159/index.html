<!DOCTYPE html>
<html>
    <head>
        <title>Home &mdash; @TheKeyboard &mdash; The ramblings of a grumpy programmer</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="/components/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
        <link href="/components/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" />
        <link href="/css/style.css" rel="stylesheet" type="text/css" />
        <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
            <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <link rel="stylesheet" href="/components/highlightjs/styles/github.css" />
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="@TheKeyboard activity feed" />
        <style>
        /** quick fix because bootstrap <pre> has a background-color. */
        pre code { background-color: inherit; }
        </style>
    </head>
    <body>
        <header>
            <div class="navbar navbar-inverse navbar-fixed-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="/">@TheKeyboard</a>
                        <div class="nav-collapse collapse">
                            <ul class="nav">
                                <li><a href="/blog">Posts Archive</a></li>
                                <li><a href="/blog/categories">Categories</a></li>
                                <li><a href="/blog/tags">Tags</a></li>
                                <li><a href="/about">About</a></li>
                            </ul>
                        </div><!--/.nav-collapse -->
                    </div>
                </div>
            </div>
        </header>
        <div class="mainContent container">
            <div class="row-fluid">
                <div class="span8">
                        <article>
        <header>
            <h2><a href="/blog/2011/04/11/book-review-epwzf">Book Review -- Easy PHP Websites with the Zend Framework</a></h2>
        </header>
        <div>
            <p>Full disclosure: Jason Gilmore publishes my book
<a href="http://www.wjgilmore.com/books/read/refactoring_legacy_applications_using_cakephp">Refactoring Legacy Applications Using CakePHP</a>
and also provided me with a free copy of his book (in both PDF and
MOBI formats) for me to review. While I consider Jason a friend, I
do not let my personal friendships interfere with an objective
review of a book.)</p>

<p>When you are going through the progress from beginner to mastery of
any web application framework, it is almost impossible to do unless
(a) you wrote the framework yourself or (b) there is excellent 3rd
party documentation available on how to use it. Even if the project
itself has really good extensive documentation (which Zend
Framework does) it is still essential that other people have
documented their usage of it in situations beyond the very limited
ones presented in the documentation provided by the project itself.
When you add to this the fact that Zend Framework is very large, is
component based, and often provides multiple solutions for the same
problem, it means that it is even more critical to find out how
other people are solving problems similar to the ones you are
facing.</p>

<p>Jason did provide me a copy of the previous version of this book as
well (it never hurts to ask people for favours...) and when he told
me at <a href="http://codemash.org">CodeMash</a> that he was putting the
finishing touches on an updated version of the book I said (a) let
me know what tools you used to build it and (b) I'd be happy to
review it when it comes out. So when I saw the announcement that
<a href="http://www.wjgilmore.com/books/read/easy_php_websites_with_the_zend_framework">Easy PHP Websites with the Zend Framework</a>
had been released I reminded Jason about my promise to review it.
Shortly thereafter an electronic copy of the book showed up in my
email.</p>

<p>At 240 pages I wouldn't say this is the type of book that you can
really read cover-to-cover at a rapid pace. I think it is more
suited as a very long and expanded HOWTO for building an
application from scratch. I was also pleased to see that Jason had
made the commitment to pushing Test Driven Development by having
the reader write tests for the site they were building as they went
along. The more people who come to understand the benefits of
writing and automating testing of the applications, the better the
applications people in the PHP community will produce.</p>

<p>In this book Jason guides you from start to finish on the creation
of GameNomad, a social networking application for console and PC
gaming enthusiasts. You start with nothing but a skeleton of a
project built using ZendTool and end up with an automated
deployment system for pushing your changes up into production. Oh,
you also end up learning how to integrate
<a href="http://jquery.org">jQuery</a> into the project as well <em>and</em> learning
how to use Git, albeit at a very basic level) to keep things
organized.</p>

<p>I know what you're thinking: how could Jason have covered anything
of substance in 240 pages. I'm going to let you in on one of the
dirty secrets of the programming profession: a social networking
site is not as complicated to build as people think it is. Facebook
itself is not complicated, what is complicated is how it has
changed over time to handle the ridonkulous traffic levels it
handles. Trust me when I tell you that Jason shows you how to build
the features that are at the core of any decent social networking
site where members post items and send messages to each other.</p>

<p>In my opinion, this book works well as a resource for beginning and
intermediate users of Zend Framework. For beginners, it guides them
from creating the application from scratch and promotes some good
practices. For the intermediate level user, it shows you how to
accomplish common tasks needed by any website that relies on
user-generated content and adding unit testing, code coverage
reports, and automated deployment skills to your toolkit.</p>

<p>I've found this book to be a good resource, even for a grumpy
veteran PHP programmer like myself. Flipping through the chapters
quickly I can find some slightly different ways of doing things on
my projects, and I really like that Jason is also showing how to
take tools outside of the PHP ecosystem and embrace them. Tools
like Git and Capistrano are there to help you, why wouldn't you
want to use them?</p>

<p>Also pay close attention to how Jason shows you the proper places
to using the various helper and plugin architectures that Zend
Framework provides you. It has been my belief that any
well-designed framework should consist of as small a core as
possible, and then allow you to extend it through plugins. Zend
Framework allows you to do exactly that, and I've very quickly
embraced plugins as an easy way to keep customized code inside a
component that can be used anywhere in the application, instead of
dealing with the problem of cutting-and-pasting code all over the
place.</p>

<p>If you want to get serious about building a real application using
Zend Framework, I would recommend you pick up a copy of Jason's
book and take your time to go through it as your building your
project. When you've got an application full of tests providing
100% code coverage <em>and</em> can be automatically deployed, you'll be
able to sleep at night without worrying about the dreaded
late-night phone call "the site is broken and you have to fix it
RIGHT NOW!!!"</p>

<p>Also check out some of Jason's other books if you're fairly new to
PHP and are looking to get up to speed faster with things like
using MySQL with PHP and integrating PayPal into your web
applications.</p>

        </div>
            </article>
    <article>
        <header>
            <h2><a href="/blog/2011/04/03/component-architecture-followup">Component Architecture -- Follow-up</a></h2>
        </header>
        <div>
            <p>After posting my thoughts on
<a href="http://www.littlehart.net/atthekeyboard/2011/03/31/component-architecture">component architectures</a>
I asked Stu Herbert to provide me with any comments he had on this
particular topic, having been the original inspiration. He was kind
enough to do so and I have extracted some of his thoughts and
weaved them into this post along with some other thoughts I've
had.</p>

<p>First of all, I did a
<a href="http://en.wikipedia.org/wiki/Facepalm">facepalm</a> when I realized
there were things I wanted to talk about in the original post that
I had missed. In his presentation at PHP UK Conference Stu pointed
out that PHP has not made the commitment to reusable components
like the other major scripting languages used currently for web
development, Ruby and Python. Ruby has it's excellent
<a href="http://en.wikipedia.org/wiki/Ruby_gems">Ruby gems</a> system to allow
the installation and distribution of components written in Ruby.
Python has two solutions that I am aware of in
<a href="http://en.wikipedia.org/wiki/EasyInstall">EasyInstall</a> and the
<a href="http://en.wikipedia.org/wiki/Python_Package_Index">Python Package Index</a>.
They both serve the same purpose: allowing the installation and
distribution of 3rd party components. In PHP
<a href="http://pear.php.net/">PEAR</a> is the system we should all be using
for doing this. The reasons why are interesting, and I'd like to
share my thoughts before we see what Stu had to say.</p>

<p>It seems to me that the difference between PEAR and the solutions
offered in Ruby and Python can be thrown into one of two piles:
cultural and technical. On the cultural side, both Python and Ruby
have encouraged developers to use these 3rd party systems as the
primary means of distributing code. I think if you look at the
popular components available in something like Rails, I think you
would be hard-pressed to find one that did not exist as a gem. My
early experiments with Rails back in 2004 made me think that the
gem system was the perfect way to handle it. Sure, you can end up
in dependency hell trying to figure out what gems go with what
other gems, but I do not think there is ever an easy solution to
that problem.</p>

<p>When you look at the technical issues, this is where I think PEAR
breaks down. As far as I can tell, to make your component available
to install with PEAR you have to create your own PEAR channel.
What? Really?!? Am I the only one who thinks that this is an
unnecessary limitation? When I added
<a href="https://github.com/chartjes/djaml">Djaml</a> to PyPi, all I had to do
was create two metadata files in a specific format and then push it
up to PyPi using tools that are provided by the same CLI utility
you install other packages with. Bingo presto, my package was now
available to anyone who wanted to use it. I didn't have to set up
my own channel. To me, this the main reason why PEAR is not the
dominant installation tool that it should be.</p>

<p>In a perfect world I would like to see all the major PHP frameworks
make themselves available via PEAR as their main method of
distribution. Wishful thinking, I know.</p>

<p>Okay, so now time for us to hear from Stu:</p>

<blockquote>
  <p>Your question "how do you decide what stuff can be extracted out
  and built into a component?" merits more than just an email ... I'm
  sure this is a conference talk / tutorial day topic in its own
  right :) Would you say that most developers could recognise a
  component if they saw one? &#42; Clearly-defined purpose &#42;
  Clearly-defined API &#42; Clearly-defined data structures &#42;
  Separation of concerns &#42; Reusable &#42; Re-installable on multiple
  computers &#42; Replaceable / substitutable</p>
  
  <p>But seeing one when designing (or refactoring!) software is
  something fewer PHP developers have had the opportunity to
  practice?</p>
</blockquote>

<p>Stu is, of course, absolutely right. It is impossible to extract
code into a reusable component if you don't even know how to
identify it. Like many, MANY skills in programming, the ability to
refactor and extract code is a skill that needs to be cultivated
and learned. I myself have run into this many times during a coding
session while refactoring. Does this sound familiar?</p>

<ul>
<li>implement some functionality</li>
<li>get a request to add something</li>
<li>realize that the new request is similar to something you've
already done</li>
</ul>

<p>The trick is realizing that the next step in this chain is not
"cut-and-paste the previous functionality because we supposedly
have no time". The next step is to extract that functionality into
something that can be re-used. Usually this in the context of the
application itself (ie extracting that code into a helper method if
you're using a framework) but it is worth thinking about how to
make that a component that can exist OUTSIDE of the application
itself.</p>

<p>More from Stu:</p>

<blockquote>
  <p>I think you hit the nail on the head towards the end of your
  article, when you started talking about services. A component could
  be defined as being: &#42; a self-contained set of code &#42; that
  provides a reusable service &#42; to a larger body of code &#42; by being
  aggregated into that code</p>
  
  <p>This differentiates it from a service-oriented architecture in one
  crucial detail: a component runs as part of your app - same address
  space, same process ID - whereas a service runs outside your app,
  and is contacted either locally via IPC or remotely via
  networking.</p>
  
  <p>But none of that helps the first-time component writer, I fear!
  This is big-picture stuff, or perhaps better described as 20/20
  hindsight stuff - things that developers can only see after they've
  learned how to do it :) What they need is their first step to
  making a component - an additive process that builds on that first
  step until components are as natural a strategy as factories, DI,
  and the like. This is very similar to how one teaches martial arts,
  where we start from the floor (how a fighter stands, how they step)
  and work upwards.</p>
</blockquote>

<p>Stu goes on to share some super sekret info with me surrounding his
plans in this area and I look forward to seeing them come to
fruition. Thanks Stu!</p>

        </div>
            </article>
    <article>
        <header>
            <h2><a href="/blog/2011/03/31/component-architecture">Component Architecture -- Why Are You Not Doing This?!?</a></h2>
        </header>
        <div>
            <p>Welcome to my last post of the
<a href="http://shiflett.org/blog/2011/mar/ideas-of-march">Ideas of March</a>
series. It's been awesome stretching out the brain and putting more
long-form thoughts in to blogposts. I hope I've spurred other
people on into doing more research and thinking about the stuff
they do as a developer. It's very easy to fall into a rut and get
comfortable, shunning new ideas and new techniques.</p>

<p>I discovered an awesome presentation by my new favourite PHP
developer, <a href="http://blog.stuartherbert.com/">Stuart Herbert</a>. Pardon
the salty language, but how the FUCK did I not know about this guy
before?!? I found out about him from this awesome presentation he
gave at the PHP UK Conference about
<a href="http://blog.stuartherbert.com/php/2011/03/20/following-up-my-beyond-frameworks-talk/">Beyond Frameworks</a>.
Talks about real-world situations always resonate a lot better with
me than a presentation about out cool some new piece of tech is
without presenting a compelling reason to use it. Not to pick on
the NoSQL guys, but please show those of us not as smart as you why
we really need it. Here's a good example of what I like to see: a
blog post from MongoDB-internals-developer-turned-web-developer
Mike Dirolf and his
<a href="http://dirolf.com/2011/03/28/new-perspective-on-mongodb.html">perspective on MongoDB</a>
is a great example of providing reasons behind someone's use of a
particular technology. Enough of that, I'm drifting off topic.
Again.</p>

<p>Stuart's presentation was all kinds of awesome because it examined
a problem that many people have (that their applications end up
being held hostage by their framework choice), showed an example of
a real problem (their own infrastructure as it crept through
several iterations), and then provided a real solution (reduce the
dependence on the framework itself by creating reusable
components). By sheer coincidence, this is the sort of things I had
been contemplating doing while still working for
<a href="http://www.xmlteam.com">XML Team Solutions</a> but in a slightly
different form. The brilliance was the leveraging of PEAR to be a
keep part of it.</p>

<p>When do you need to start thinking about a component architecture?
When you find yourself reimplementing the same thing for different
applications. At XML Team, there were hints that this needed to be
done. Requests to allow users of one application be allowed to use
their authentication credentials on another. A desire to refactor a
web service plus web GUI in order to simplify the internals because
we were mixing up theming with the web service stuff. Add to it a
dash that I was relying too heavily on framework tools that might
make it tough to do things like add an IOS application for clients,
and I realized that there were some serious architectural changes
on the horizon that some people really wanted to ignore.</p>

<p>But here's the really tricky part (and I'd love for Stuart to
follow-up on this) about the decision: how do you decide what stuff
can be extracted out and built into a component? Without a clear
method for figuring this out, there will be no movement in that
direction. The main reason is what I like to call the Precious
Snowflake Problem. The PSP is a double-edged sword for most
developers when trying to determine whether or not to write
something from scratch or adapt someone else's code. It is my
learn-ed opinion that most developers overestimate the uniqueness
of their particular set of problems. It's natural that we emphasize
the differences and ignore the sameness.</p>

<p>But it has also been the genesis of a lot of really
technology-advancing projects. Developer becomes frustrated with
existing tool that won't work quite the way they want it to, so
they go and create their own version of it. I don't have enough
time to list all the successful projects that have come out of
this. My intention here is not to slam those who wish to scratch
the proverbial itch, but to try and focus attention on how to
determine when some subset of functionality in one application is
similar enough to another that you can extract it and simply build
in the differences by reacting to a sane number of parameters
passed in. My personal feeling is that unless you are introducing a
major paradigm shift for a particular technology, you are better
off building on what others have already done. Let me provide an
example.</p>

<p>The <a href="http://lithify.me">Lithium</a> project is an example of what I
would call introducing a paradigm shift for a particular
technology. It was one of the earliest proponents of making their
framework compatible with PHP 5.3 and newer. Why? So they could
take advantage of closures / anonymous functions / whatever you
wish to call them in order to apply some unique features to the
framework. This would allow for some neat stuff like filters (in my
opinion a very-underrated feature that I expect to see appearing in
the next generation of Zend Framework and Symfony) <em>and</em> result in
less code being written. At the same time, it is code that makes
sense: creating stuff that gets done at certain, well-defined
points in the request cycle. At least I <em>think</em> that's what it is
supposed to be doing.</p>

<p>Let's take a look at my example of the desire to share
authentication between multiple applications. If you have
applications using different frameworks, well, you are going to
have to do this from the bottom up and invent a service these apps
can talk to. Maybe a web service is the way to go: provide the
credentials and shoot back the response because your applications
live on different servers. Perhaps a better solution is to make it
authenticate at the code level, thereby only having a database call
instead of a web service call and the associated database call.
What is good is that you are ACTUALLY THINKING ABOUT HOW TO
ABSTRACT IT OUT. Personally, my plan would've been to create a
code-related solution provided via a component because the two
applications in question lived on the same server, but breaking the
database-backed information into it's own database to make it
easier to move somewhere else should the need arise.</p>

<p>Decisions like this require courage and resolve. No, it's not a
cliche. It's the truth. You will encounter resistance towards your
efforts to make sense of the spaghetti and allow you to move to an
architecture where your framework of choice becomes a very thin
layer on top of a bunch of reusable, tested components. Who doesn't
want to work with a code base like that?</p>

<p>My final Idea of March: embrace the power of component
architectures and do what you can to move your own applications
(and company or even framework project) towards it. The best sign
that you're there? A very lean core for your application with lots
of components being called in as you need them, not monolithic full
stack applications where everything you need and then some is
always being included.</p>

<p>I hope you've enjoyed my contribution to the Ideas Of March for
2011, and perhaps I will resurrect it in 2012.</p>

        </div>
            </article>
    <nav>
        <a href="/page/158">Newer Posts</a><br />
        <a href="/page/160">Older Posts</a><br />
    </nav>
                </div>
                <div class="span4 sidebar">
                    <div class="well">
                        <h4>@TheKeyboard <small>The ramblings of a grumpy programmer</small></h4>
                    </div>
                    <div class="well sidebar-nav">
                        <h4>Links</h4>
                        <ul class="nav">
                            <li><a href="http://sculpin.io">sculpin.io</a></li>
                            <li><a href="http://twitter.com/getsculpin">@getsculpin</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <footer class="container">
            &copy; 2014 @TheKeyboard
        </footer>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="/components/jquery/jquery.min.js"><\/script>')</script>
        <script src="/components/bootstrap/js/bootstrap.min.js"></script>
                
                <script src="/components/highlightjs/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
