<!DOCTYPE html>
<html>
    <head>
        <title>Home &mdash; @TheKeyboard &mdash; The ramblings of a grumpy programmer</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="/components/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
        <link href="/components/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" />
        <link href="/css/style.css" rel="stylesheet" type="text/css" />
        <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
            <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <link rel="stylesheet" href="/components/highlightjs/styles/github.css" />
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="@TheKeyboard activity feed" />
        <style>
        /** quick fix because bootstrap <pre> has a background-color. */
        pre code { background-color: inherit; }
        </style>
    </head>
    <body>
        <header>
            <div class="navbar navbar-inverse navbar-fixed-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="/">@TheKeyboard</a>
                        <div class="nav-collapse collapse">
                            <ul class="nav">
                                <li><a href="/blog">Posts Archive</a></li>
                                <li><a href="/blog/categories">Categories</a></li>
                                <li><a href="/blog/tags">Tags</a></li>
                                <li><a href="/about">About</a></li>
                            </ul>
                        </div><!--/.nav-collapse -->
                    </div>
                </div>
            </div>
        </header>
        <div class="mainContent container">
            <div class="row-fluid">
                <div class="span8">
                        <article>
        <header>
            <h2><a href="/_posts/2007-04-04-keep-an-eye-on-your-radar.markdown"></a></h2>
        </header>
        <div>
            <hr />

<p>layout: post</p>

<h2>title: Keep An Eye On Your RADAR</h2>

<p>Over at the PragDave blog (written by Dave Thomas of the Pragmatic Programmers) he has a very interesting article about a <a href="http://pragdave.pragprog.com/pragdave/2007/03/the_radar_archi.html">new architecture for web applications</a> that he calls RADAR for RESTful Application, Dumb-Ass Recipient.  Why do I think this is important?  Because it makes so much sense. :)</p>

<p>
In a nutshell, he is advocating that you build the core of your web application to supply information via a REST application server, then create a proxy server that can serve up the information in HTML format for clients that can't easily speak REST's language of XML responses, like a web browser.  He has a great section in there:

<blockquote>
Does that mean I'm down on the RESTful, CRUD based approach to application development? Not at all. For some categories of application, I think it's a great way of structuring your code. But REST isn't designed for talking to people. So let's accept that fact when creating applications. And, while we're at it, let's take advantage of the fact that HTTP is such a flexible transport. Rather than trying to design one monolithic application than has both the CRUD functionality and the smarts to be able to talk HTML to end users, why not split it into two smaller and simpler applications?
</blockquote>

So, you can still serve up your data with REST for "smart clients" that can directly manipulate the XML resulting from a REST call, but why not filter the REST response through some code that can then output a much-easier-for-humans-to-read version in HTML?
</p>

<p>
This isn't really a radical concept, as most people are doing something similar to this already in their code.  He is just advocating doing this on a more defined level instead of just in your code.  See, in Ruby on Rails you have the ability to specify what controller / action pair you want for different output types using something called 'respond_to'.  Now, I've used it a tiny bit and while it is a very neat bit of code, it does look kind of hackish to me as well.
</p>

<p>
Instead, continue to use a REST service as the core application server and then have, for example, an HTML application server that will read data from the REST service and manipulating so it looks real-pretty-like for display purposes.  Ironically, before I read this article I had been structuring the new IBL web site along these lines.  That site is kicking me in the ass because it's PHP 4 only, and PHP 4's XML parsing is just terrible.  Give me SimpleXML or give me death!  Nate has been helping me figure out how to use the XML object in CakePHP, but I have to do a lot of work on the data before it's in a presentable format.  Maybe I will do as Nate suggested and try pushing the XML stuff into the new Set object and see what happens.  You never know.
</p>

<p>
Anyhow, check out the article on RADAR and see what sort of ideas it gives you in terms of restructuring the architecture of your application.  Simple is good, and this looks like a very simple architecture to understand.
</p>

        </div>
            </article>
    <article>
        <header>
            <h2><a href="/_posts/2007-04-05-lazyweb-need-a-t-shirt-artist.markdown"></a></h2>
        </header>
        <div>
            <hr />

<p>layout: post</p>

<h2>title: "Lazyweb: Need a t-shirt artist"</h2>

<p>I need a design for a t-shirt done up for me, based on the phrase "Be a developer, not a typist!".  If you can help me out on a pro-bono basis, send some mail to chartjes@littlehart.net.
</p>

        </div>
            </article>
    <article>
        <header>
            <h2><a href="/_posts/2007-04-11-doing-radar-in-cakephp.markdown"></a></h2>
        </header>
        <div>
            <hr />

<p>layout: post
title: Doing RADAR in CakePHP
date: 2007-04-11</p>

<h2>author: Chris Hartjes</h2>

<p>Okay, time for some code samples to boost traffic to my site.  In a previous posting I talked about the idea of <a href="http://www.littlehart.net/atthekeyboard/2007/04/04/keep-an-eye-on-your-radar/">RADAR</a>, or RESTful Application, Dumb-Ass Recipient.  So, wanting to see if I could put it into use, I decided to do the following for a new application:
<ul>
<li>Have the core of the application provide data via a REST service</li>
<li>For the web part of it, create controller / action pairs that call the REST service and pass the output onto the views</li></ul>
I'm hoping that some of the other programmers in the league (there are a few) get interested in using the REST API I've put together and build off of it.  The API is in place, so they can build their own apps around it.  Should be an interesting experiment anyway.
</p>

<p>
So, some code examples of building CakePHP apps the RADAR way:
~~~
class IndexController extends AppController
{
    var $name = 'Index';
    var $uses = array('Game', 'Schedule');

    function index()
    {
        uses('XML');
        $game = new Game();
        $week = $game->getMaxWeek();

        // Pass these variables to the view
        $standings =& new XML($this->requestAction('/rest/standings/' . $week , array('return')));
        $schedule =& new XML($this->requestAction('/rest/schedule/' . $week, array('return')));
        $results =& new XML($this->requestAction('/rest/results/' . $week, array('return')));
        $this->set('results', $results);
        $this->set('schedule', $schedule);
        $this->set('standings', $standings);
        $this->set('week', $week);
    }
}
~~~
This is the controller for the "portal" page of the new web site I'm working on.  Since I don't have access to PHP 5 for this project, I have to use the built-in XML object instead of SimpleXML (curse you, PHP 4).  The key here is the use of requestAction to hit my REST API and return the response, and then pipe that response into an XML object, that in turn gets passed to the view.  Since I like my clean URL's, I'm using the same trick I used before in the REST controller's so I can do http://host/rest/results and get it to spit back XML:
~~~
    /**
     * REST service for return games for the requested week
     *
     * @param integer $week
     */
    function results($week)
    {
        $games = new Game();
        $this->set('results', $games->getWeeklyResult($week));
        $this->set('week', $week);
    }

    /**
     * REST service for returning schedule for particular week
     *
     * @param integer $week
     */
    function schedule($week) {
        $team = array("a01" => "COU", "a02" => "CAP", "a03" => "TRI", "a04" => "BUF",
              "a05" => "MCM", "a06" => "WMS", "a07" => "PHI", "a08" => "BOW",
              "a09" => "STL", "a10" => "PAD", "a11" => "POR", "a12" => "LAW",
              "n01" => "SDQ", "n02" => "CSP", "n03" => "MIN", "n04" => "CAJ",
              "n05" => "BUZ", "n06" => "HAG", "n07" => "DTR", "n08" => "COL",
              "n09" => "SPO", "n10" => "SEA", "n11" => "MAD", "n12" => "CRE");

        $schedule = new Schedule();
        $this->set(compact('week', 'team'));
        $this->set('results', $schedule->get($week));
    }

    /**
     * Output standings based on the week passed into it
     *
     * @param integer $week
     */
    function standings($week)
    {
        $divisions = array('AC West' => array("STL" => "St. Louis Rivermen", "PAD" => "Palo Alto Devils", "POR" => "Portland Gryphons", "LAW" => "Los Angeles Wildmen"),
                          'AC Central' => array("MCM" => "Motor City Marauders", "WMS" => "Williamstown Thunder", "PHI" => "Philadelphia Phantasm", "BOW" => "Bowling Green Bandits"),
                          'AC East' => array("COU" => "Chicago Cougars", "CAP" => "Capital City Fruit Bats", "TRI" => "Tri-State Traffic", "BUF" => "Buffalo Thunderherd"),
                          'NC West' => array("MAD" => "Monrovia Madness", "SEA" => "Seattle Rainers", "SPO" => "Spokane Chiefs", "CRE" => "Crescent City Redwoods"),
                          'NC Central' => array("BUZ" => "Boston Buzzards", "COL" => "Colorado Corsairs", "HAG" => "Habana Gigantes", "DTR" => "Detroit Rangers"),
                          'NC East' => array("CSP" => "Casper Ghosts", "MIN" => "Minnesota Snow Bears", "SDQ" => "San Diego Quakes", "CAJ" => "Carolina Cajuns")
                          );
        $standings = new Standings();
        $standings->getData($week);

        foreach ($divisions as $divisionName => $divisionTeams) {
            $divisionStandings[$divisionName] = $standings->getDivisionalStandings($divisionTeams);
        }

        $this->set('divisionStandings', $divisionStandings);
    }
~~~
I'm planning on making the index action for the REST controller point to documentation on how to actually use it, which I think is a nice touch.
</p>

<p>
Okay, so now one of the views using the XML object.  Again, I think it's such an ugly hack because I can't use SimpleXML.  Nate has discussed with me the possibility of trying to make something built-in to CakePHP that uses a SimpleXML-like interface so that it will work in PHP 4 as well.  We shall see...
~~~
<br /><br />
<center>Standings as of week < ?php echo $week ?><br /><br /></center>
<?php
$standings = $standings->child('standings');
$divisionalStandings = $standings->children('division');
?>
<center>
<table>
    <tr>
        <td>< ?php echo $this->renderElement('divisional_standings', array('division' => $divisionalStandings[0])) ?></td>
        <td>< ?php echo $this->renderElement('divisional_standings', array('division' => $divisionalStandings[3])) ?></td>
    </tr>
    <tr>
        <td>< ?php echo $this->renderElement('divisional_standings', array('division' => $divisionalStandings[1])) ?></td>
        <td>< ?php echo $this->renderElement('divisional_standings', array('division' => $divisionalStandings[4])) ?></td>
    </tr>
    <tr>
        <td>< ?php echo $this->renderElement('divisional_standings', array('division' => $divisionalStandings[2])) ?></td>
        <td>< ?php echo $this->renderElement('divisional_standings', array('division' => $divisionalStandings[5])) ?></td>
    </tr>
</table>
</center>
~~~
That's the main view for doing the standings, and it's done as an element called in my main index view.  Now, here's the view that actually generates the standings for a particular division:
~~~
<table>
    <tr>
        <th><b>< ?php echo $division->attributes['name'] ?></b></th>
        <th><b>W</b></th>
        <th><b>L</b></th>
        <th><b>Pct</b></th>
        <th><b>GB</b></th>
    </tr>
<?php foreach ($division->children('team') as $team) : ?>
    <?php
    $name = $team->child('name');
    $w = $team->child('w');
    $l = $team->child('l');
    $gb = $team->child('gb');
    $pct = $team->child('pct');
    ?>
    <tr>
        <td>< ?php echo $name->value ?></td>
        <td align='right'>< ?php echo $w->value ?></td>
        <td align='right'>< ?php echo $l->value ?></td>
        <td align='right'>< ?php echo sprintf("%0.3f", $pct->value) ?></td>
        <td align='right'>< ?php echo $gb->value ?></td>
    </tr>
<?php endforeach; ?>
</table>
~~~
</p>

<p>
So, there you have it!  Remember, the idea of RADAR is that you have a REST service at the core of your application, and then you provide a "proxy" for dumb clients like browsers that only understand HTML natively.  That way you make your application it's own API, and everything else is just clients that hang off the API.  As an example, I could build a plugin for the sidebar of my <a href="http://www.littlehart.net/attheballpark">baseball blog</a> that shows the standings for the division my team is in.  I could hit the REST service, then manipulate the results via XML and spit it out.  
</p>

<p>
I hope the example above gives you a different perspective on putting together your application.
</p>

        </div>
            </article>
    <nav>
        <a href="/page/52">Newer Posts</a><br />
        <a href="/page/54">Older Posts</a><br />
    </nav>
                </div>
                <div class="span4 sidebar">
                    <div class="well">
                        <h4>@TheKeyboard <small>The ramblings of a grumpy programmer</small></h4>
                    </div>
                    <div class="well sidebar-nav">
                        <h4>Links</h4>
                        <ul class="nav">
                            <li><a href="http://sculpin.io">sculpin.io</a></li>
                            <li><a href="http://twitter.com/getsculpin">@getsculpin</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <footer class="container">
            &copy; 2014 @TheKeyboard
        </footer>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="/components/jquery/jquery.min.js"><\/script>')</script>
        <script src="/components/bootstrap/js/bootstrap.min.js"></script>
                
                <script src="/components/highlightjs/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
