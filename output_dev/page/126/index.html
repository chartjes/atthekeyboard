<!DOCTYPE html>
<html>
    <head>
        <title>Home &mdash; @TheKeyboard &mdash; The ramblings of a grumpy programmer</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="/components/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
        <link href="/components/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" />
        <link href="/css/style.css" rel="stylesheet" type="text/css" />
        <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
            <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <link rel="stylesheet" href="/components/highlightjs/styles/github.css" />
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="@TheKeyboard activity feed" />
        <style>
        /** quick fix because bootstrap <pre> has a background-color. */
        pre code { background-color: inherit; }
        </style>
    </head>
    <body>
        <header>
            <div class="navbar navbar-inverse navbar-fixed-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="/">@TheKeyboard</a>
                        <div class="nav-collapse collapse">
                            <ul class="nav">
                                <li><a href="/blog">Posts Archive</a></li>
                                <li><a href="/blog/categories">Categories</a></li>
                                <li><a href="/blog/tags">Tags</a></li>
                                <li><a href="/about">About</a></li>
                            </ul>
                        </div><!--/.nav-collapse -->
                    </div>
                </div>
            </div>
        </header>
        <div class="mainContent container">
            <div class="row-fluid">
                <div class="span8">
                        <article>
        <header>
            <h2><a href="/_posts/2010-03-02-people-who-make-me-feel-stupid-antirez.markdown"></a></h2>
        </header>
        <div>
            <hr />

<p>layout: post</p>

<h2>title: "People Who Make Me Feel Stupid: Antirez"</h2>

<p>This is the second of a five-part series where I highlight some developers who are doing work or espousing practices that make me feel stupid and realize where I need to push my skills towards.  Today's source of inspiration:  the man know by many online as <a href="http://antirez.com/">Antirez</a>, Italian software developer Salvatore Sanfilippo.</p>

<p>Antirez is the driving force behind <a href="http://code.google.com/p/redis/">Redis</a>, which is described as "an advanced key-value store" where it holds your dataset in memory at all times but writes them out to disk in a couple of different ways depending on your choices (either from time-to-time or all the time to an append log, depending on what level of consistency you need from the data).
</p>

<p>When I first started watching the whole <a href="http://en.wikipedia.org/wiki/NoSQL">NoSQL</a> movement, I remember seeing Redis in there as an option there.  However, I didn't know much about Redis until I noticed that my friend <a href="http://twitter.com/jperras">Joel Perras</a> was following this guy with an awesome mop of hair in his Twitter avatar and a cool nickname.  When I also saw he was the creator of Redis I knew this was a guy I had to follow and see what he was up to.
</p>

<p>
I won't go into the whole rationale behind the NoSQL movement, but what makes me feel stupid is not just the *way* Antirez has chose to implement his key-value storage solution, but the man himself.  He is one really smart dude.
</p>

<p>
First of all, he might be the most prolific hacker I've seen out there who actually lets people know what he's been up to.  His Twitter stream is full of comments about stuff he's been working on in Redis, some of which I understand and some of which goes right over my head (especially the <a href="http://antirez.com/post/redis-virtual-memory-story.html">stuff about the Virtual Memory work he's done with Redis</a> just shows me what I missed by not taking computer science courses.  Too busy teaching myself the new and shiny I guess.
</p>

<p>
Second, he spits out this volume of information in English.  Which is NOT his first language.  I couldn't imagine translating technical terms into my second fairly proficient language (which is German, and I understand it spoken way better than I speak it, read it or write it).  I have a hard enough time understanding technical terms written in English, never mind translating them in my head from another language.
</p>

<p>
So back to Redis now.  So not only is it a high-performance key-value store, using memory (the fastest storage medium) to store your data, but it also suited for use in a master-slave replication setup (claiming very fast replication speeds, and given the torturous bench marks I have seen Antirez talk about on twitter and his blog, I believe him) but can also do something that a lot of post-relational data stores (perhaps that's a better name than NoSQL) can't do:  unions (am I correct in assuming that is the equivalent of JOINS from the SQL world?), set intersections, comparisons between sets, and even generating sorted results.  I could see using Redis as the data store for the web front end of the corporate fantasy draft application at work.  I'm using a lot of key-value pairs in it, so a hybrid approach would probably work the best if I were to try it.
</p>

<p>
I mean, when you read that Virtual Memory post how can you *not* feel stupid for failing to see why Redis needs such a thing:  if you are storing everything in memory (remember, disk is the new tape) then you need your use of that memory to be as advantageous as possible and not rely on the operating system to do it for you.  For Redis, you want to keep as much memory available for your data so Antirez felt that he needed to find a way to free up the memory being used by the least-frequently accessed data.  A hard problem to solve for sure, but reading about what he did is just so inspiring.  As a bonus, you also learn some computer science skills along the way.  I felt the same way when I listened to a lecture about building virtual machines for Ruby:  awed and wondering if they teach that sort of stuff in computer science courses.
</p>

<p>While Redis might not be a solution I ever use at work (I am trying to keep our stack from adding too many new components just because I feel like playing with them) it's worth the lost hours reading Antirez' blog to understand all that goes on behind the scenes to make a cool piece of technology usable outside some very narrow scenarios.
</p>

<p>So, in the end, why did Antirez make me feel stupid?  <b>It was because he made me realize that you could take a simple idea (the key-value store) and add all sorts of very desirable features onto it without compromising it's main goal</b>.
</p>

        </div>
            </article>
    <article>
        <header>
            <h2><a href="/_posts/2010-03-03-people-who-make-me-feel-stupid-rich-hickey.markdown"></a></h2>
        </header>
        <div>
            <hr />

<p>layout: post</p>

<h2>title: "People Who Make Me Feel Stupid: Rich Hickey"</h2>

<p><i>This is the third in a series of blog posts where I talk about people who's skills as programmers make me feel stupid.  Check out my thoughts on <a href="http://www.littlehart.net/atthekeyboard/2010/03/01/people-who-make-me-feel-stupid-geoffrey-grosenbach/">Geoffrey Grosenbach</a> and <a href="http://www.littlehart.net/atthekeyboard/2010/03/02/people-who-make-me-feel-stupid-antirez/">Antirez</a>.</i>
</p>

<p>
As a person who learned the hard way about how tough it is creating web applications that can handle state and concurrency  issues (if you've ever seen MySQL replication lag times as high as 30 *minutes* you can sympathize), the rise of languages designed from the ground up to support concurrency has caught my eye.  If you've heard of <a href="http://erlang.org">Erlang</a> or <a href="http://www.haskell.org/">Haskell</a> you are somewhat familiar with the topic.
</p>

<p>
Then one day I ran across <a href="http://clojure.org/">Clojure</a>, a language that is a dialect of Lisp but runs on the JVM.  My, my, what in interesting combination.  I've talked about Clojure before, but I have not talked about the amazing person behind it, <a href="http://en.wikipedia.org/wiki/Rich_Hickey">Rich Hickey</a>.
</p>

<p>
The idea of <a href="http://createyourproglang.com/">creating your own programming language</a> is one that I find extremely intimidating, not having a formal background in computer science.  I have a vague idea of how you would do it:  write parsers for your code and then compile them into byte code that can be run by something.  Very simplistic, I know.
</p>

<p>
So Rich Hickey is a one of these programming gurus who I am sure is a super-nice guy but I would be totally intimidated to have any sort of meaningful programming-related discussion with.  First of all, he's a Lisp hacker.  Some of my friends have described Lisp as "the cockroach of the programming world, which will be around long after the sun of other languages have dimmed" and I can't say that I disagree much with that statement.  For someone who learned to program by teaching himself PHP, Lisp's syntax takes a lot of getting used to.  
</p>

<p>But then I think the best trick was making Clojure run on the <a href="http://en.wikipedia.org/wiki/Jvm">JVM</a>.  Why do I think this is significant?  It means that if there is a feature or a library that doesn't exist in Clojure, you can always use a Java equivalent (if such a one exists).  In Tim Bray's "Concur Next" series he showed an example where he used a Java library in Clojure to help him speed things up.
</p>

<p>
So not only does he have a well-designed and well-thought-out programming language, he is also great at explaining programming concepts.  Go and watch this video on the topic of <a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">basic principles like state, identity, value, time, and many others</a> in order to understand how to build concurrent and parallel systems.  Fascinating talk, and I highly recommend seeking out other talks that he's done as well.
</p>

<p>
All this stuff is absolutely fascinating to me, because my entire programming career has been spent in the stateless environment of the web.  Oh sure, we can fake state and concurrency using sessions and cookies, but they are really just hacks.  Does a web application need to be stateful and/or concurrent?  The answer is, of course, it depends. ;)  Online games with multiple participants definitely need to worry about sharing state across multiple clients, and any web application that is taking large amounts of data and processing it (like munging it together based on aggregate conditions) could benefit from being able to crunch the data concurrently, with all jobs reporting stuff as they go.  Any task that would benefit from being broken down into smaller tasks that can be run at once is a candidate for concurrency.
</p>

<p>
So, why does Rich Hickey make me feel stupid?  <b>Not only is he also capable of explaining the hows and whys of a concurrent programming language, he is encouraging people to think ahead to the next generation of programming problems and potential solutions to those problems.</b>.  It's highly unlikely I will ever create a full-blown, general-purpose programming language.  But Rich Hickey's work has gotten me thinking about programming in event-driven environments, and wondering what tasks that my current applications perform could benefit from concurrency and parallelism.
</p>

        </div>
            </article>
    <article>
        <header>
            <h2><a href="/_posts/2010-03-04-people-who-make-me-feel-stupid-ezra-zygmuntowicz.markdown"></a></h2>
        </header>
        <div>
            <hr />

<p>layout: post</p>

<h2>title: "People Who Make Me Feel Stupid: Ezra Zygmuntowicz"</h2>

<p><i>This is the 4th out of 5 blog posts about programmers who I find make me feel stupid when I read what they write or hear them speak.  Stupid because what they say is so obvious I cannot believe I missed it.  See my thoughts on <a href="http://www.littlehart.net/atthekeyboard/2010/03/01/people-who-make-me-feel-stupid-geoffrey-grosenbach/">Geoffrey Grosenbach</a>, <a href="http://www.littlehart.net/atthekeyboard/2010/03/02/people-who-make-me-feel-stupid-antirez/">Antirez</a> and <a href="http://www.littlehart.net/atthekeyboard/2010/03/03/people-who-make-me-feel-stupid-rich-hickey/">Rich Hickey</a>.</i>
</p>

<p>
Next up is another prominent member of the Ruby community, one that I feel truly deserves the label "Renaissance Programmer".  He is <a href="http://brainspl.at/">Ezra Zygmuntowicz</a>, co-founder of <a href="http://www.engineyard.com">Engine Yard</a>, probably the leader in helping people deploy Rails applications of all shapes and sizes.  Ezra seems to have done it all, from Rails work, to <a href="http://merbivore.com/">Merb</a>, to the Ruby VM <a href="http://rubini.us/">Rubinus</a>.
</p>

<p>
If I remember correctly, I first encountered Ezra and his work (and his awesome last name) during my Ruby on Rails research.  Realizing that Rails was the dominate framework in that space, I wondered what the alternatives were.  That lead me to Merb.  Unfortunately at the time it was not well-documented, so I drifted into other things (like so many other times, I'm sensing a pattern here).  Then I started hearing about the efforts to create an alternative to the standard Ruby virtual machine, with the goal of creating, I imagine, a faster Ruby environment.
</p>

<p>Much as I cannot imagine writing my own programming language, I could not imagine creating a virtual machine based on running code in an already-established language.  Then I saw <a href="http://www.youtube.com/watch?v=TcMklv40YMY">this talk</a> Ezra gave about Merb, Rubinus and the stack that Engine Yard uses.  What blew me away was when he started explaining *how* he was going about implementing Rubinus.  It made so much sense.
</p>

<p>
See, in the Ruby world you can use what they call Matz' Ruby Interpreter, or CRuby as a reference point.  Since there is no official spec, the MRI is used.  So if you want to create your own Ruby virtual machine, it's as simple as looking at how the MRI implements functionality and then copy it in your own VM.  Repeat until your own virtual machine passes all the tests in the <a href="http://rubyspec.org/">RubySpec</a> project and bingo!  You have a (hopefully as close to compatible with the MRI) virtual machine for running Ruby.  It seems that <a href="http://en.wikipedia.org/wiki/YARV">YARV</a> is a virtual machine (I believe it is a bytecode interpreter) that is included with the latest version of Ruby at this writing, 1.9.
</p>

<p>
So why does Ezra make me feel stupid: <b>He has fully immersed himself in the Ruby world from the virtual machine to the language implementation to frameworks that sit on top of it.  Like most of the people I talk about in this series, he also knows how to explain these things to people in such a way that you do not realize what awesome work he is doing.</b>
</p>

<p>
I may not be doing anything with Ruby any more, but how can you not get interested in the nuts-and-bolts of a language and virtual machines in general when someone like Ezra explains it to you?!?  In the PHP world, Facebook recently announced the release and open sourcing of <a href="http://wiki.github.com/facebook/hiphop-php/">Hip Hop for PHP</a>.  This project takes PHP code, parses it and generates C++ executables.  This is a big deal for Facebook, who is the largest user of PHP out there.  It lets them use approximately 50% fewer servers when delivering PHP-results.  They did the same thing I talked about above:  looked at how PHP implemented functions at the lowest level, and then figured out how to do it in C++.  It's a very unique project, and obviously not for everyone.  But again, an awesome case study on creating virtual machines / alternate runtimes for an existing programming language.
</p>

        </div>
            </article>
    <nav>
        <a href="/page/125">Newer Posts</a><br />
        <a href="/page/127">Older Posts</a><br />
    </nav>
                </div>
                <div class="span4 sidebar">
                    <div class="well">
                        <h4>@TheKeyboard <small>The ramblings of a grumpy programmer</small></h4>
                    </div>
                    <div class="well sidebar-nav">
                        <h4>Links</h4>
                        <ul class="nav">
                            <li><a href="http://sculpin.io">sculpin.io</a></li>
                            <li><a href="http://twitter.com/getsculpin">@getsculpin</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <footer class="container">
            &copy; 2014 @TheKeyboard
        </footer>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="/components/jquery/jquery.min.js"><\/script>')</script>
        <script src="/components/bootstrap/js/bootstrap.min.js"></script>
                
                <script src="/components/highlightjs/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
